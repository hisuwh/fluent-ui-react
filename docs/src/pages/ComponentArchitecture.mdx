export const meta = {
  title: 'Component Architecture',
}

The design and architecture of components should follow from a set of first principles.

- There is 1 right way to do things, and it's easy to do the right thing.
- Consumers should not be penalized for code they don't use (through bundle size, perf, etc).
- Don't overgeneralize until we have a clear need (abstracting should solve a bundle size goal, or DRY goal, or partner use case)

# Base components

Each component should be built upon a "base component".

In order to keep sorted lists formatted neatly, each base component should be named with the form: `ComponentNameBase.tsx`

#### Applications which load their own CSS in other means should not pay the penalty of loading a runtime CSS-in-JS package, especially if the class names are known at time of authoring.

Base components should expect a prop called `classes`, which is either a
dictionary of keys to classnames (where a key represents a portion of the DOM), or
a callback which will return the same dictionary when called with the component's
state.

#### Applications which want to override specific aspects of a component should not incur a penalty of loading a concretely referenced component that will not be rendered in the final output.

Base components should expect a prop called `slots`, which is a dictionary of element names mapped
to their respective concrete implementation. The base component should default to rendering native DOM
elements for each slot unless an override is passed.

#### Any external dependencies mean negative parsing time, bundle size and runtime impact for consumers that don't intend to use them.

Base components should get all outside information exclusively from `props`.

#### Hooks provide a desirable level of abstraction between business logic and markup. Reusable hooks further provide consumers with the ability to reuse smaller pieces of library controls.

Hooks should be created to manage internal state of base components. For sets
of functionality common to several components, shared hooks should be abstracted
and exported from a common platform package.

#### There is a limited set of accessibility options that work well together, and each combination should be tested cohesively. Further, accessibility is closely tied to a components internal state, and they are likely to iterate concurrently.

Each base component with accessibility concerns should provide its own implementation of accessibility props and handlers.
For variants that are expected in the overall component library, state hooks should be reused and a new component simply
created with a different use-case.

It is important to have consistent accessibility, and passing in a new accessibility model might create major
challenges to keep our components accessible, and also predictable. If a particular component needs to have multiple
accessibility models (keyboarding, attributes), it should make that decision based on a single prop with a fixed set
of implementation options (i.e. a `accessibilityMode` prop that accepts a fixed set of string values as input).

# Themed components

The control library should ship a set of unopinionated components (i.e. base components) but also components which are
pre-scaffolded with Fluent design opinions (themed components). Fluent will be opinionated but customizable.

#### Themed components are the glue that ties together context, theming, and the base component. There are several potential implementations (`createComponent`, other HoCs), but serve as the higher level abstraction that brings only the necessary pieces to a consumer's application bundle.

Themed components should pass a set of classes to base components. In practice, this will mean pulling
together information about theming and styling from context, and ensuring the correct CSS is rendered on
the page.

#### The themed layer is the preferred layer to add hard graph edges. Each themed control should be intuitive to use for a developer, and should come with "batteries included".

Each themed component that relies on sub-components should specify which components to render through
the slots prop.

The slots prop must be accessible in several means to ensure that a "recursive component" can be accurately described.

#### We want to offer a delightful first-run experience, and bundle size will not be negatively impacted by including the default theme.

Each component should render a known-good theme out of the box when used without a provider.

#### As a component library cannot anticipate all needs to applications' design systems, allowances should be made to extend the design system while maintaining rich levels of type safety.

The HoC used to glue base components to the rest of the system should also provide a facility
to define a variant. A variant is defined as an additional prop on the created component which has
the ability to adjust the look and feel of the component.

#### Themed components pass through unhandled but filtered props, which should be rendered on the `root` of a base component

Each themed control should accept any number of props that will be rendered by the base control's root slot.
The base control should leverage a platform library's function to pass all relevant native props to appropriate
controls whenever available.

# Code organization

#### Iterating on both Fluent UI and Fabric has shed light on several difficult versioning issues. A feature of a code organization approach would let customers opt in to potential breaking changes without requiring a major release for a nominally trivial breaking change.

Each component will live in its own package, with `@next`
versions of components published at will. This allows consumers to
opt-in to specific versions of new components without requiring a
sweeping set of changes to an application.

A “meta-package” will also be published for casual consumers. A
meta-package will allow a consumer to snap to major versions of all
components and will be the quickest path to get up and running in a new
project.
